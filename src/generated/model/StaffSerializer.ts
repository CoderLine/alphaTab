// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>
import { Staff } from "@src/model/Staff";
import { IJsonReader } from "@src/io/IJsonReader";
import { JsonValueType } from "@src/io/IJsonReader";
import { IJsonWriter } from "@src/io/IJsonWriter";
import { BarSerializer } from "@src/generated/model/BarSerializer";
import { ChordSerializer } from "@src/generated/model/ChordSerializer";
import { Bar } from "@src/model/Bar";
import { Chord } from "@src/model/Chord";
export class StaffSerializer {
    public static fromJson(obj: Staff, r: IJsonReader): void {
        if (r.currentValueType !== JsonValueType.Object) {
            return;
        } 
        while (r.nextProp()) {
            this.setProperty(obj, r.prop().toLowerCase(), r);
        } 
    }
    public static toJson(obj: Staff | null, w: IJsonWriter): void {
        if (!obj) {
            w.null();
            return;
        } 
        w.startObject(); 
        w.prop("index"); 
        w.number(obj.index); 
        w.prop("bars"); 
        w.startArray(); 
        for (const i of obj.bars) {
            BarSerializer.toJson(i, w);
        } 
        w.endArray(); 
        w.prop("chords"); 
        w.startObject(); 
        obj.chords.forEach((v, k) => { w.prop(k); ChordSerializer.toJson(v, w); }); 
        w.endObject(); 
        w.prop("capo"); 
        w.number(obj.capo); 
        w.prop("transpositionPitch"); 
        w.number(obj.transpositionPitch); 
        w.prop("displayTranspositionPitch"); 
        w.number(obj.displayTranspositionPitch); 
        w.prop("tuning"); 
        w.numberArray(obj.tuning); 
        w.prop("tuningName"); 
        w.string(obj.tuningName); 
        w.prop("showTablature"); 
        w.boolean(obj.showTablature); 
        w.prop("showStandardNotation"); 
        w.boolean(obj.showStandardNotation); 
        w.prop("isPercussion"); 
        w.boolean(obj.isPercussion); 
        w.prop("standardNotationLineCount"); 
        w.number(obj.standardNotationLineCount); 
        w.endObject(); 
    }
    public static setProperty(obj: Staff, property: string, r: IJsonReader): boolean {
        switch (property) {
            case "index":
                obj.index = (r.number()!);
                return true;
            case "bars":
                obj.bars = [];
                while (r.nextItem()) {
                    const i = new Bar();
                    BarSerializer.fromJson(i, r)
                    obj.addBar(i);
                }
                return true;
            case "chords":
                obj.chords = new Map<string, Chord>();
                while (r.nextProp()) {
                    const i = new Chord();
                    ChordSerializer.fromJson(i, r);
                    obj.addChord(r.prop(), i);
                }
                return true;
            case "capo":
                obj.capo = (r.number()!);
                return true;
            case "transpositionpitch":
                obj.transpositionPitch = (r.number()!);
                return true;
            case "displaytranspositionpitch":
                obj.displayTranspositionPitch = (r.number()!);
                return true;
            case "tuning":
                obj.tuning = (r.numberArray()!);
                return true;
            case "tuningname":
                obj.tuningName = (r.string()!);
                return true;
            case "showtablature":
                obj.showTablature = (r.boolean()!);
                return true;
            case "showstandardnotation":
                obj.showStandardNotation = (r.boolean()!);
                return true;
            case "ispercussion":
                obj.isPercussion = (r.boolean()!);
                return true;
            case "standardnotationlinecount":
                obj.standardNotationLineCount = (r.number()!);
                return true;
        } 
        return false; 
    }
}

