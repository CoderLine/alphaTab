// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>
import { MasterBar } from "@src/model/MasterBar";
import { SectionSerializer } from "@src/generated/model/SectionSerializer";
import { AutomationSerializer } from "@src/generated/model/AutomationSerializer";
import { FermataSerializer } from "@src/generated/model/FermataSerializer";
import { KeySignature } from "@src/model/KeySignature";
import { KeySignatureType } from "@src/model/KeySignatureType";
import { TripletFeel } from "@src/model/TripletFeel";
import { Section } from "@src/model/Section";
import { Automation } from "@src/model/Automation";
import { Fermata } from "@src/model/Fermata";
export class MasterBarSerializer {
    public static fromJson(json: any): MasterBar {
        const obj = new MasterBar(); 
        this.fillFromJson(obj, json); 
        return obj; 
    }
    public static fillFromJson(obj: MasterBar, json: any): void {
        if (json) {
            for (const $k in json) {
                this.setProperty(obj, $k.toLowerCase(), json[$k]);
            }
        } 
    }
    public static toJson(obj: MasterBar | null): any {
        if (!obj) {
            return null;
        } 
        const json: any = {}; 
        this.fillToJson(obj, json); 
        return json; 
    }
    public static fillToJson(obj: MasterBar, json: any): void {
        json.alternateEndings = obj.alternateEndings; 
        json.index = obj.index; 
        json.keySignature = obj.keySignature; 
        json.keySignatureType = obj.keySignatureType; 
        json.isDoubleBar = obj.isDoubleBar; 
        json.isRepeatStart = obj.isRepeatStart; 
        json.repeatCount = obj.repeatCount; 
        json.timeSignatureNumerator = obj.timeSignatureNumerator; 
        json.timeSignatureDenominator = obj.timeSignatureDenominator; 
        json.timeSignatureCommon = obj.timeSignatureCommon; 
        json.tripletFeel = obj.tripletFeel; 
        if (json.section) {
            if (obj.section) {
                SectionSerializer.fillToJson(obj.section, json.section);
            }
        }
        else {
            json.section = SectionSerializer.toJson(obj.section);
        } 
        if (json.tempoAutomation) {
            if (obj.tempoAutomation) {
                AutomationSerializer.fillToJson(obj.tempoAutomation, json.tempoAutomation);
            }
        }
        else {
            json.tempoAutomation = AutomationSerializer.toJson(obj.tempoAutomation);
        } 
        json.fermata = ({} as any); 
        obj.fermata.forEach(($mv, $mk) => { (json.fermata as any)[$mk] = FermataSerializer.toJson($mv); }); 
        json.start = obj.start; 
        json.isAnacrusis = obj.isAnacrusis; 
    }
    public static setProperty(obj: MasterBar, property: string, value: any): boolean {
        switch (property) {
            case "alternateendings":
                obj.alternateEndings = value;
                return true;
            case "index":
                obj.index = value;
                return true;
            case "keysignature":
                obj.keySignature = isNaN(parseInt(value)) ? KeySignature[Object.keys(KeySignature).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof KeySignature] : parseInt(value);
                return true;
            case "keysignaturetype":
                obj.keySignatureType = isNaN(parseInt(value)) ? KeySignatureType[Object.keys(KeySignatureType).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof KeySignatureType] : parseInt(value);
                return true;
            case "isdoublebar":
                obj.isDoubleBar = value;
                return true;
            case "isrepeatstart":
                obj.isRepeatStart = value;
                return true;
            case "repeatcount":
                obj.repeatCount = value;
                return true;
            case "timesignaturenumerator":
                obj.timeSignatureNumerator = value;
                return true;
            case "timesignaturedenominator":
                obj.timeSignatureDenominator = value;
                return true;
            case "timesignaturecommon":
                obj.timeSignatureCommon = value;
                return true;
            case "tripletfeel":
                obj.tripletFeel = isNaN(parseInt(value)) ? TripletFeel[Object.keys(TripletFeel).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof TripletFeel] : parseInt(value);
                return true;
            case "fermata":
                obj.fermata = new Map<number, Fermata>();
                for (let $mk in value)
                    if (value.hasOwnProperty($mk))
                        obj.fermata.set(parseInt($mk), FermataSerializer.fromJson(value[$mk]));
                return true;
            case "start":
                obj.start = value;
                return true;
            case "isanacrusis":
                obj.isAnacrusis = value;
                return true;
        } 
        if (["section"].indexOf(property) >= 0) {
            if (obj.section)
                SectionSerializer.fillFromJson(obj.section, value);
            else
                obj.section = value ? SectionSerializer.fromJson(value) : null;
            return true;
        }
        else {
            for (const $c of ["section"])
                if (property.indexOf($c) === 0) {
                    if (!obj.section) {
                        obj.section = new Section();
                    }
                    if (SectionSerializer.setProperty(obj.section, property.substring($c.length), value)) {
                        return true;
                    }
                }
        } 
        if (["tempoautomation"].indexOf(property) >= 0) {
            if (obj.tempoAutomation)
                AutomationSerializer.fillFromJson(obj.tempoAutomation, value);
            else
                obj.tempoAutomation = value ? AutomationSerializer.fromJson(value) : null;
            return true;
        }
        else {
            for (const $c of ["tempoautomation"])
                if (property.indexOf($c) === 0) {
                    if (!obj.tempoAutomation) {
                        obj.tempoAutomation = new Automation();
                    }
                    if (AutomationSerializer.setProperty(obj.tempoAutomation, property.substring($c.length), value)) {
                        return true;
                    }
                }
        } 
        return false; 
    }
}

