// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>
import { MasterBar } from "@src/model/MasterBar";
import { IJsonReader } from "@src/io/IJsonReader";
import { JsonValueType } from "@src/io/IJsonReader";
import { IJsonWriter } from "@src/io/IJsonWriter";
import { SectionSerializer } from "@src/generated/model/SectionSerializer";
import { AutomationSerializer } from "@src/generated/model/AutomationSerializer";
import { FermataSerializer } from "@src/generated/model/FermataSerializer";
import { KeySignature } from "@src/model/KeySignature";
import { KeySignatureType } from "@src/model/KeySignatureType";
import { TripletFeel } from "@src/model/TripletFeel";
import { Section } from "@src/model/Section";
import { Automation } from "@src/model/Automation";
import { Fermata } from "@src/model/Fermata";
export class MasterBarSerializer {
    public static fromJson(obj: MasterBar, reader: IJsonReader): void {
        if (reader.currentValueType !== JsonValueType.Object) {
            return;
        } 
        while (reader.nextProperty()) {
            this.setProperty(obj, reader.readPropertyName().toLowerCase(), reader);
        } 
    }
    public static toJson(obj: MasterBar | null, writer: IJsonWriter): void {
        if (!obj) {
            writer.writeNull();
            return;
        } 
        writer.writeStartObject(); 
        writer.writePropertyName("alternateEndings"); 
        writer.writeNumber(obj.alternateEndings); 
        writer.writePropertyName("index"); 
        writer.writeNumber(obj.index); 
        writer.writePropertyName("keySignature"); 
        writer.writeEnum(obj.keySignature); 
        writer.writePropertyName("keySignatureType"); 
        writer.writeEnum(obj.keySignatureType); 
        writer.writePropertyName("isDoubleBar"); 
        writer.writeBoolean(obj.isDoubleBar); 
        writer.writePropertyName("isRepeatStart"); 
        writer.writeBoolean(obj.isRepeatStart); 
        writer.writePropertyName("repeatCount"); 
        writer.writeNumber(obj.repeatCount); 
        writer.writePropertyName("timeSignatureNumerator"); 
        writer.writeNumber(obj.timeSignatureNumerator); 
        writer.writePropertyName("timeSignatureDenominator"); 
        writer.writeNumber(obj.timeSignatureDenominator); 
        writer.writePropertyName("timeSignatureCommon"); 
        writer.writeBoolean(obj.timeSignatureCommon); 
        writer.writePropertyName("tripletFeel"); 
        writer.writeEnum(obj.tripletFeel); 
        writer.writePropertyName("section"); 
        if (obj.section) {
            SectionSerializer.toJson(obj.section, writer);
        }
        else
            writer.writeNull(); 
        writer.writePropertyName("tempoAutomation"); 
        if (obj.tempoAutomation) {
            AutomationSerializer.toJson(obj.tempoAutomation, writer);
        }
        else
            writer.writeNull(); 
        writer.writePropertyName("fermata"); 
        writer.writeStartObject(); 
        obj.fermata.forEach((v, k) => { writer.writePropertyName(k); FermataSerializer.toJson(v, writer); }); 
        writer.writeEndObject(); 
        writer.writePropertyName("start"); 
        writer.writeNumber(obj.start); 
        writer.writePropertyName("isAnacrusis"); 
        writer.writeBoolean(obj.isAnacrusis); 
        writer.writeEndObject(); 
    }
    public static setProperty(obj: MasterBar, property: string, reader: IJsonReader): boolean {
        switch (property) {
            case "alternateendings":
                obj.alternateEndings = (reader.readNumber()!);
                return true;
            case "index":
                obj.index = (reader.readNumber()!);
                return true;
            case "keysignature":
                obj.keySignature = (reader.readEnum<KeySignature>(KeySignature)!);
                return true;
            case "keysignaturetype":
                obj.keySignatureType = (reader.readEnum<KeySignatureType>(KeySignatureType)!);
                return true;
            case "isdoublebar":
                obj.isDoubleBar = (reader.readBoolean()!);
                return true;
            case "isrepeatstart":
                obj.isRepeatStart = (reader.readBoolean()!);
                return true;
            case "repeatcount":
                obj.repeatCount = (reader.readNumber()!);
                return true;
            case "timesignaturenumerator":
                obj.timeSignatureNumerator = (reader.readNumber()!);
                return true;
            case "timesignaturedenominator":
                obj.timeSignatureDenominator = (reader.readNumber()!);
                return true;
            case "timesignaturecommon":
                obj.timeSignatureCommon = (reader.readBoolean()!);
                return true;
            case "tripletfeel":
                obj.tripletFeel = (reader.readEnum<TripletFeel>(TripletFeel)!);
                return true;
            case "fermata":
                obj.fermata = new Map<number, Fermata>();
                while (reader.nextProperty()) {
                    const i = new Fermata();
                    FermataSerializer.fromJson(i, reader);
                    obj.fermata.set(reader.readPropertyNameAsNumber(), i);
                }
                return true;
            case "start":
                obj.start = (reader.readNumber()!);
                return true;
            case "isanacrusis":
                obj.isAnacrusis = (reader.readBoolean()!);
                return true;
        } 
        if (["section"].indexOf(property) >= 0) {
            if (reader.currentValueType !== JsonValueType.Null) {
                obj.section = new Section();
                SectionSerializer.fromJson(obj.section, reader);
            }
            else {
                obj.section = null;
            }
            return true;
        } 
        if (["tempoautomation"].indexOf(property) >= 0) {
            if (reader.currentValueType !== JsonValueType.Null) {
                obj.tempoAutomation = new Automation();
                AutomationSerializer.fromJson(obj.tempoAutomation, reader);
            }
            else {
                obj.tempoAutomation = null;
            }
            return true;
        } 
        return false; 
    }
}

