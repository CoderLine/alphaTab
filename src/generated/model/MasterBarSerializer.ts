// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>
import { MasterBar } from "@src/model/MasterBar";
import { IJsonReader } from "@src/io/IJsonReader";
import { JsonValueType } from "@src/io/IJsonReader";
import { IJsonWriter } from "@src/io/IJsonWriter";
import { SectionSerializer } from "@src/generated/model/SectionSerializer";
import { AutomationSerializer } from "@src/generated/model/AutomationSerializer";
import { FermataSerializer } from "@src/generated/model/FermataSerializer";
import { KeySignature } from "@src/model/KeySignature";
import { KeySignatureType } from "@src/model/KeySignatureType";
import { TripletFeel } from "@src/model/TripletFeel";
import { Section } from "@src/model/Section";
import { Automation } from "@src/model/Automation";
import { Fermata } from "@src/model/Fermata";
export class MasterBarSerializer {
    public static fromJson(obj: MasterBar, r: IJsonReader): void {
        if (r.currentValueType !== JsonValueType.Object) {
            return;
        } 
        while (r.nextProp()) {
            this.setProperty(obj, r.prop().toLowerCase(), r);
        } 
    }
    public static toJson(obj: MasterBar | null, w: IJsonWriter): void {
        if (!obj) {
            w.null();
            return;
        } 
        w.startObject(); 
        w.prop("alternateEndings"); 
        w.number(obj.alternateEndings); 
        w.prop("index"); 
        w.number(obj.index); 
        w.prop("keySignature"); 
        w.enum(obj.keySignature); 
        w.prop("keySignatureType"); 
        w.enum(obj.keySignatureType); 
        w.prop("isDoubleBar"); 
        w.boolean(obj.isDoubleBar); 
        w.prop("isRepeatStart"); 
        w.boolean(obj.isRepeatStart); 
        w.prop("repeatCount"); 
        w.number(obj.repeatCount); 
        w.prop("timeSignatureNumerator"); 
        w.number(obj.timeSignatureNumerator); 
        w.prop("timeSignatureDenominator"); 
        w.number(obj.timeSignatureDenominator); 
        w.prop("timeSignatureCommon"); 
        w.boolean(obj.timeSignatureCommon); 
        w.prop("tripletFeel"); 
        w.enum(obj.tripletFeel); 
        w.prop("section"); 
        if (obj.section) {
            SectionSerializer.toJson(obj.section, w);
        }
        else
            w.null(); 
        w.prop("tempoAutomation"); 
        if (obj.tempoAutomation) {
            AutomationSerializer.toJson(obj.tempoAutomation, w);
        }
        else
            w.null(); 
        w.prop("fermata"); 
        w.startObject(); 
        obj.fermata.forEach((v, k) => { w.prop(k); FermataSerializer.toJson(v, w); }); 
        w.endObject(); 
        w.prop("start"); 
        w.number(obj.start); 
        w.prop("isAnacrusis"); 
        w.boolean(obj.isAnacrusis); 
        w.endObject(); 
    }
    public static setProperty(obj: MasterBar, property: string, r: IJsonReader): boolean {
        switch (property) {
            case "alternateendings":
                obj.alternateEndings = (r.number()!);
                return true;
            case "index":
                obj.index = (r.number()!);
                return true;
            case "keysignature":
                obj.keySignature = (r.enum<KeySignature>(KeySignature)!);
                return true;
            case "keysignaturetype":
                obj.keySignatureType = (r.enum<KeySignatureType>(KeySignatureType)!);
                return true;
            case "isdoublebar":
                obj.isDoubleBar = (r.boolean()!);
                return true;
            case "isrepeatstart":
                obj.isRepeatStart = (r.boolean()!);
                return true;
            case "repeatcount":
                obj.repeatCount = (r.number()!);
                return true;
            case "timesignaturenumerator":
                obj.timeSignatureNumerator = (r.number()!);
                return true;
            case "timesignaturedenominator":
                obj.timeSignatureDenominator = (r.number()!);
                return true;
            case "timesignaturecommon":
                obj.timeSignatureCommon = (r.boolean()!);
                return true;
            case "tripletfeel":
                obj.tripletFeel = (r.enum<TripletFeel>(TripletFeel)!);
                return true;
            case "fermata":
                obj.fermata = new Map<number, Fermata>();
                while (r.nextProp()) {
                    const i = new Fermata();
                    FermataSerializer.fromJson(i, r);
                    obj.fermata.set(r.numberProp(), i);
                }
                return true;
            case "start":
                obj.start = (r.number()!);
                return true;
            case "isanacrusis":
                obj.isAnacrusis = (r.boolean()!);
                return true;
        } 
        if (["section"].indexOf(property) >= 0) {
            if (r.currentValueType !== JsonValueType.Null) {
                obj.section = new Section();
                SectionSerializer.fromJson(obj.section, r);
            }
            else {
                obj.section = null;
            }
            return true;
        } 
        if (["tempoautomation"].indexOf(property) >= 0) {
            if (r.currentValueType !== JsonValueType.Null) {
                obj.tempoAutomation = new Automation();
                AutomationSerializer.fromJson(obj.tempoAutomation, r);
            }
            else {
                obj.tempoAutomation = null;
            }
            return true;
        } 
        return false; 
    }
}

