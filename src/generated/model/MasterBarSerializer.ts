// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>
import { MasterBar } from "@src/model/MasterBar";
import { JsonReader } from "@src/io/JsonReader";
import { JsonValueType } from "@src/io/JsonReader";
import { JsonWriter } from "@src/io/JsonWriter";
import { SectionSerializer } from "@src/generated/model/SectionSerializer";
import { AutomationSerializer } from "@src/generated/model/AutomationSerializer";
import { FermataSerializer } from "@src/generated/model/FermataSerializer";
import { KeySignature } from "@src/model/KeySignature";
import { KeySignatureType } from "@src/model/KeySignatureType";
import { TripletFeel } from "@src/model/TripletFeel";
import { Section } from "@src/model/Section";
import { Automation } from "@src/model/Automation";
import { Fermata } from "@src/model/Fermata";
export class MasterBarSerializer {
    public static fromJson(obj: MasterBar, r: JsonReader): void {
        if (r.currentValueType === JsonValueType.Null) {
            return;
        } 
        r.startObject(); 
        while (r.nextProp()) {
            this.setProperty(obj, r.prop().toLowerCase(), r);
        } 
        r.endObject(); 
    }
    public static toJson(obj: MasterBar | null, w: JsonWriter): void {
        if (!obj) {
            w.null();
            return;
        } 
        w.startObject(); 
        w.number(obj.alternateEndings, "alternateEndings"); 
        w.number(obj.index, "index"); 
        w.enum(obj.keySignature, "keySignature"); 
        w.enum(obj.keySignatureType, "keySignatureType"); 
        w.boolean(obj.isDoubleBar, "isDoubleBar"); 
        w.boolean(obj.isRepeatStart, "isRepeatStart"); 
        w.number(obj.repeatCount, "repeatCount"); 
        w.number(obj.timeSignatureNumerator, "timeSignatureNumerator"); 
        w.number(obj.timeSignatureDenominator, "timeSignatureDenominator"); 
        w.boolean(obj.timeSignatureCommon, "timeSignatureCommon"); 
        w.enum(obj.tripletFeel, "tripletFeel"); 
        w.prop("section"); 
        if (obj.section) {
            SectionSerializer.toJson(obj.section, w);
        }
        else
            w.null(); 
        w.prop("tempoAutomation"); 
        if (obj.tempoAutomation) {
            AutomationSerializer.toJson(obj.tempoAutomation, w);
        }
        else
            w.null(); 
        w.prop("fermata"); 
        w.startObject(); 
        obj.fermata.forEach((v, k) => { w.prop(k); FermataSerializer.toJson(v, w); }); 
        w.endObject(); 
        w.number(obj.start, "start"); 
        w.boolean(obj.isAnacrusis, "isAnacrusis"); 
        w.endObject(); 
    }
    public static setProperty(obj: MasterBar, property: string, r: JsonReader): boolean {
        switch (property) {
            case "alternateendings":
                obj.alternateEndings = (r.number()!);
                return true;
            case "index":
                obj.index = (r.number()!);
                return true;
            case "keysignature":
                obj.keySignature = (r.enum<KeySignature>(KeySignature)!);
                return true;
            case "keysignaturetype":
                obj.keySignatureType = (r.enum<KeySignatureType>(KeySignatureType)!);
                return true;
            case "isdoublebar":
                obj.isDoubleBar = (r.boolean()!);
                return true;
            case "isrepeatstart":
                obj.isRepeatStart = (r.boolean()!);
                return true;
            case "repeatcount":
                obj.repeatCount = (r.number()!);
                return true;
            case "timesignaturenumerator":
                obj.timeSignatureNumerator = (r.number()!);
                return true;
            case "timesignaturedenominator":
                obj.timeSignatureDenominator = (r.number()!);
                return true;
            case "timesignaturecommon":
                obj.timeSignatureCommon = (r.boolean()!);
                return true;
            case "tripletfeel":
                obj.tripletFeel = (r.enum<TripletFeel>(TripletFeel)!);
                return true;
            case "fermata":
                obj.fermata = new Map<number, Fermata>();
                r.startObject();
                while (r.nextProp()) {
                    const i = new Fermata();
                    FermataSerializer.fromJson(i, r);
                    obj.fermata.set(r.numberProp(), i);
                }
                r.endObject();
                return true;
            case "start":
                obj.start = (r.number()!);
                return true;
            case "isanacrusis":
                obj.isAnacrusis = (r.boolean()!);
                return true;
        } 
        if (["section"].indexOf(property) >= 0) {
            if (r.currentValueType !== JsonValueType.Null) {
                obj.section = new Section();
                SectionSerializer.fromJson(obj.section, r);
            }
            else {
                obj.section = null;
            }
            return true;
        } 
        if (["tempoautomation"].indexOf(property) >= 0) {
            if (r.currentValueType !== JsonValueType.Null) {
                obj.tempoAutomation = new Automation();
                AutomationSerializer.fromJson(obj.tempoAutomation, r);
            }
            else {
                obj.tempoAutomation = null;
            }
            return true;
        } 
        return false; 
    }
}

