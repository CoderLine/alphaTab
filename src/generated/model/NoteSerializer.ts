// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>
import { Note } from "@src/model/Note";
import { BendPointSerializer } from "@src/generated/model/BendPointSerializer";
import { AccentuationType } from "@src/model/AccentuationType";
import { BendType } from "@src/model/BendType";
import { BendStyle } from "@src/model/BendStyle";
import { HarmonicType } from "@src/model/HarmonicType";
import { SlideInType } from "@src/model/SlideInType";
import { SlideOutType } from "@src/model/SlideOutType";
import { VibratoType } from "@src/model/VibratoType";
import { Fingers } from "@src/model/Fingers";
import { Duration } from "@src/model/Duration";
import { NoteAccidentalMode } from "@src/model/NoteAccidentalMode";
import { DynamicValue } from "@src/model/DynamicValue";
export class NoteSerializer {
    public static fromJson(json: any): Note {
        const obj = new Note(); 
        this.fillFromJson(obj, json); 
        return obj; 
    }
    public static fillFromJson(obj: Note, json: any): void {
        if (json) {
            for (const $k in json) {
                this.setProperty(obj, $k.toLowerCase(), json[$k]);
            }
        } 
    }
    public static toJson(obj: Note | null): any {
        if (!obj) {
            return null;
        } 
        const json: any = {}; 
        this.fillToJson(obj, json); 
        return json; 
    }
    public static fillToJson(obj: Note, json: any): void {
        json.id = obj.id; 
        json.index = obj.index; 
        json.accentuated = obj.accentuated; 
        json.bendType = obj.bendType; 
        json.bendStyle = obj.bendStyle; 
        json.isContinuedBend = obj.isContinuedBend; 
        json.bendPoints = obj.bendPoints.map($li => BendPointSerializer.toJson($li)); 
        json.fret = obj.fret; 
        json.string = obj.string; 
        json.octave = obj.octave; 
        json.tone = obj.tone; 
        json.percussionArticulation = obj.percussionArticulation; 
        json.isVisible = obj.isVisible; 
        json.isLeftHandTapped = obj.isLeftHandTapped; 
        json.isHammerPullOrigin = obj.isHammerPullOrigin; 
        json.hammerPullOriginNoteId = obj.hammerPullOriginNoteId; 
        json.hammerPullDestinationNoteId = obj.hammerPullDestinationNoteId; 
        json.isSlurDestination = obj.isSlurDestination; 
        json.slurOriginNoteId = obj.slurOriginNoteId; 
        json.slurDestinationNoteId = obj.slurDestinationNoteId; 
        json.harmonicType = obj.harmonicType; 
        json.harmonicValue = obj.harmonicValue; 
        json.isGhost = obj.isGhost; 
        json.isLetRing = obj.isLetRing; 
        json.isPalmMute = obj.isPalmMute; 
        json.isDead = obj.isDead; 
        json.isStaccato = obj.isStaccato; 
        json.slideInType = obj.slideInType; 
        json.slideOutType = obj.slideOutType; 
        json.vibrato = obj.vibrato; 
        json.tieOriginNoteId = obj.tieOriginNoteId; 
        json.tieDestinationNoteId = obj.tieDestinationNoteId; 
        json.isTieDestination = obj.isTieDestination; 
        json.leftHandFinger = obj.leftHandFinger; 
        json.rightHandFinger = obj.rightHandFinger; 
        json.isFingering = obj.isFingering; 
        json.trillValue = obj.trillValue; 
        json.trillSpeed = obj.trillSpeed; 
        json.durationPercent = obj.durationPercent; 
        json.accidentalMode = obj.accidentalMode; 
        json.dynamics = obj.dynamics; 
        json.isEffectSlurOrigin = obj.isEffectSlurOrigin; 
        json.hasEffectSlur = obj.hasEffectSlur; 
    }
    public static setProperty(obj: Note, property: string, value: any): boolean {
        switch (property) {
            case "id":
                obj.id = value;
                return true;
            case "index":
                obj.index = value;
                return true;
            case "accentuated":
                obj.accentuated = isNaN(parseInt(value)) ? AccentuationType[Object.keys(AccentuationType).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof AccentuationType] : parseInt(value);
                return true;
            case "bendtype":
                obj.bendType = isNaN(parseInt(value)) ? BendType[Object.keys(BendType).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof BendType] : parseInt(value);
                return true;
            case "bendstyle":
                obj.bendStyle = isNaN(parseInt(value)) ? BendStyle[Object.keys(BendStyle).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof BendStyle] : parseInt(value);
                return true;
            case "iscontinuedbend":
                obj.isContinuedBend = value;
                return true;
            case "bendpoints":
                obj.bendPoints = [];
                for (const $li of value)
                    obj.bendPoints.push(BendPointSerializer.fromJson($li));
                return true;
            case "fret":
                obj.fret = value;
                return true;
            case "string":
                obj.string = value;
                return true;
            case "octave":
                obj.octave = value;
                return true;
            case "tone":
                obj.tone = value;
                return true;
            case "percussionarticulation":
                obj.percussionArticulation = value;
                return true;
            case "isvisible":
                obj.isVisible = value;
                return true;
            case "islefthandtapped":
                obj.isLeftHandTapped = value;
                return true;
            case "ishammerpullorigin":
                obj.isHammerPullOrigin = value;
                return true;
            case "hammerpulloriginnoteid":
                obj.hammerPullOriginNoteId = value;
                return true;
            case "hammerpulldestinationnoteid":
                obj.hammerPullDestinationNoteId = value;
                return true;
            case "isslurdestination":
                obj.isSlurDestination = value;
                return true;
            case "sluroriginnoteid":
                obj.slurOriginNoteId = value;
                return true;
            case "slurdestinationnoteid":
                obj.slurDestinationNoteId = value;
                return true;
            case "harmonictype":
                obj.harmonicType = isNaN(parseInt(value)) ? HarmonicType[Object.keys(HarmonicType).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof HarmonicType] : parseInt(value);
                return true;
            case "harmonicvalue":
                obj.harmonicValue = value;
                return true;
            case "isghost":
                obj.isGhost = value;
                return true;
            case "isletring":
                obj.isLetRing = value;
                return true;
            case "ispalmmute":
                obj.isPalmMute = value;
                return true;
            case "isdead":
                obj.isDead = value;
                return true;
            case "isstaccato":
                obj.isStaccato = value;
                return true;
            case "slideintype":
                obj.slideInType = isNaN(parseInt(value)) ? SlideInType[Object.keys(SlideInType).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof SlideInType] : parseInt(value);
                return true;
            case "slideouttype":
                obj.slideOutType = isNaN(parseInt(value)) ? SlideOutType[Object.keys(SlideOutType).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof SlideOutType] : parseInt(value);
                return true;
            case "vibrato":
                obj.vibrato = isNaN(parseInt(value)) ? VibratoType[Object.keys(VibratoType).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof VibratoType] : parseInt(value);
                return true;
            case "tieoriginnoteid":
                obj.tieOriginNoteId = value;
                return true;
            case "tiedestinationnoteid":
                obj.tieDestinationNoteId = value;
                return true;
            case "istiedestination":
                obj.isTieDestination = value;
                return true;
            case "lefthandfinger":
                obj.leftHandFinger = isNaN(parseInt(value)) ? Fingers[Object.keys(Fingers).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof Fingers] : parseInt(value);
                return true;
            case "righthandfinger":
                obj.rightHandFinger = isNaN(parseInt(value)) ? Fingers[Object.keys(Fingers).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof Fingers] : parseInt(value);
                return true;
            case "isfingering":
                obj.isFingering = value;
                return true;
            case "trillvalue":
                obj.trillValue = value;
                return true;
            case "trillspeed":
                obj.trillSpeed = isNaN(parseInt(value)) ? Duration[Object.keys(Duration).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof Duration] : parseInt(value);
                return true;
            case "durationpercent":
                obj.durationPercent = value;
                return true;
            case "accidentalmode":
                obj.accidentalMode = isNaN(parseInt(value)) ? NoteAccidentalMode[Object.keys(NoteAccidentalMode).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof NoteAccidentalMode] : parseInt(value);
                return true;
            case "dynamics":
                obj.dynamics = isNaN(parseInt(value)) ? DynamicValue[Object.keys(DynamicValue).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof DynamicValue] : parseInt(value);
                return true;
            case "iseffectslurorigin":
                obj.isEffectSlurOrigin = value;
                return true;
            case "haseffectslur":
                obj.hasEffectSlur = value;
                return true;
        } 
        return false; 
    }
}

