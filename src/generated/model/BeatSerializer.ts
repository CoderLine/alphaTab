// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>
import { Beat } from "@src/model/Beat";
import { NoteSerializer } from "@src/generated/model/NoteSerializer";
import { AutomationSerializer } from "@src/generated/model/AutomationSerializer";
import { BendPointSerializer } from "@src/generated/model/BendPointSerializer";
import { BendStyle } from "@src/model/BendStyle";
import { Ottavia } from "@src/model/Ottavia";
import { Duration } from "@src/model/Duration";
import { BrushType } from "@src/model/BrushType";
import { WhammyType } from "@src/model/WhammyType";
import { VibratoType } from "@src/model/VibratoType";
import { GraceType } from "@src/model/GraceType";
import { PickStroke } from "@src/model/PickStroke";
import { CrescendoType } from "@src/model/CrescendoType";
import { DynamicValue } from "@src/model/DynamicValue";
import { BeamDirection } from "@src/rendering/utils/BeamDirection";
import { BeatBeamingMode } from "@src/model/Beat";
export class BeatSerializer {
    public static fromJson(json: any): Beat {
        const obj = new Beat(); 
        this.fillFromJson(obj, json); 
        return obj; 
    }
    public static fillFromJson(obj: Beat, json: any): void {
        if (json) {
            for (const $k in json) {
                this.setProperty(obj, $k.toLowerCase(), json[$k]);
            }
        } 
    }
    public static toJson(obj: Beat | null): any {
        if (!obj) {
            return null;
        } 
        const json: any = {}; 
        this.fillToJson(obj, json); 
        return json; 
    }
    public static fillToJson(obj: Beat, json: any): void {
        json.id = obj.id; 
        json.index = obj.index; 
        json.notes = obj.notes.map($li => NoteSerializer.toJson($li)); 
        json.isEmpty = obj.isEmpty; 
        json.whammyStyle = obj.whammyStyle; 
        json.ottava = obj.ottava; 
        json.isLegatoOrigin = obj.isLegatoOrigin; 
        json.duration = obj.duration; 
        json.isLetRing = obj.isLetRing; 
        json.isPalmMute = obj.isPalmMute; 
        json.automations = obj.automations.map($li => AutomationSerializer.toJson($li)); 
        json.dots = obj.dots; 
        json.fadeIn = obj.fadeIn; 
        json.lyrics = obj.lyrics ? obj.lyrics.slice() : null; 
        json.hasRasgueado = obj.hasRasgueado; 
        json.pop = obj.pop; 
        json.slap = obj.slap; 
        json.tap = obj.tap; 
        json.text = obj.text; 
        json.brushType = obj.brushType; 
        json.brushDuration = obj.brushDuration; 
        json.tupletDenominator = obj.tupletDenominator; 
        json.tupletNumerator = obj.tupletNumerator; 
        json.isContinuedWhammy = obj.isContinuedWhammy; 
        json.whammyBarType = obj.whammyBarType; 
        json.whammyBarPoints = obj.whammyBarPoints.map($li => BendPointSerializer.toJson($li)); 
        json.vibrato = obj.vibrato; 
        json.chordId = obj.chordId; 
        json.graceType = obj.graceType; 
        json.pickStroke = obj.pickStroke; 
        json.tremoloSpeed = obj.tremoloSpeed; 
        json.crescendo = obj.crescendo; 
        json.displayStart = obj.displayStart; 
        json.playbackStart = obj.playbackStart; 
        json.displayDuration = obj.displayDuration; 
        json.playbackDuration = obj.playbackDuration; 
        json.dynamics = obj.dynamics; 
        json.invertBeamDirection = obj.invertBeamDirection; 
        json.preferredBeamDirection = obj.preferredBeamDirection; 
        json.isEffectSlurOrigin = obj.isEffectSlurOrigin; 
        json.beamingMode = obj.beamingMode; 
    }
    public static setProperty(obj: Beat, property: string, value: any): boolean {
        switch (property) {
            case "id":
                obj.id = value;
                return true;
            case "index":
                obj.index = value;
                return true;
            case "notes":
                obj.notes = [];
                for (const $li of value)
                    obj.addNote(NoteSerializer.fromJson($li));
                return true;
            case "isempty":
                obj.isEmpty = value;
                return true;
            case "whammystyle":
                obj.whammyStyle = isNaN(parseInt(value)) ? BendStyle[Object.keys(BendStyle).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof BendStyle] : parseInt(value);
                return true;
            case "ottava":
                obj.ottava = isNaN(parseInt(value)) ? Ottavia[Object.keys(Ottavia).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof Ottavia] : parseInt(value);
                return true;
            case "islegatoorigin":
                obj.isLegatoOrigin = value;
                return true;
            case "duration":
                obj.duration = isNaN(parseInt(value)) ? Duration[Object.keys(Duration).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof Duration] : parseInt(value);
                return true;
            case "isletring":
                obj.isLetRing = value;
                return true;
            case "ispalmmute":
                obj.isPalmMute = value;
                return true;
            case "automations":
                obj.automations = [];
                for (const $li of value)
                    obj.automations.push(AutomationSerializer.fromJson($li));
                return true;
            case "dots":
                obj.dots = value;
                return true;
            case "fadein":
                obj.fadeIn = value;
                return true;
            case "lyrics":
                obj.lyrics = value ? value.slice() : null;
                return true;
            case "hasrasgueado":
                obj.hasRasgueado = value;
                return true;
            case "pop":
                obj.pop = value;
                return true;
            case "slap":
                obj.slap = value;
                return true;
            case "tap":
                obj.tap = value;
                return true;
            case "text":
                obj.text = value;
                return true;
            case "brushtype":
                obj.brushType = isNaN(parseInt(value)) ? BrushType[Object.keys(BrushType).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof BrushType] : parseInt(value);
                return true;
            case "brushduration":
                obj.brushDuration = value;
                return true;
            case "tupletdenominator":
                obj.tupletDenominator = value;
                return true;
            case "tupletnumerator":
                obj.tupletNumerator = value;
                return true;
            case "iscontinuedwhammy":
                obj.isContinuedWhammy = value;
                return true;
            case "whammybartype":
                obj.whammyBarType = isNaN(parseInt(value)) ? WhammyType[Object.keys(WhammyType).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof WhammyType] : parseInt(value);
                return true;
            case "whammybarpoints":
                obj.whammyBarPoints = [];
                for (const $li of value)
                    obj.addWhammyBarPoint(BendPointSerializer.fromJson($li));
                return true;
            case "vibrato":
                obj.vibrato = isNaN(parseInt(value)) ? VibratoType[Object.keys(VibratoType).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof VibratoType] : parseInt(value);
                return true;
            case "chordid":
                obj.chordId = value;
                return true;
            case "gracetype":
                obj.graceType = isNaN(parseInt(value)) ? GraceType[Object.keys(GraceType).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof GraceType] : parseInt(value);
                return true;
            case "pickstroke":
                obj.pickStroke = isNaN(parseInt(value)) ? PickStroke[Object.keys(PickStroke).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof PickStroke] : parseInt(value);
                return true;
            case "tremolospeed":
                obj.tremoloSpeed = value === null ? null : isNaN(parseInt(value)) ? Duration[Object.keys(Duration).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof Duration] : parseInt(value);
                return true;
            case "crescendo":
                obj.crescendo = isNaN(parseInt(value)) ? CrescendoType[Object.keys(CrescendoType).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof CrescendoType] : parseInt(value);
                return true;
            case "displaystart":
                obj.displayStart = value;
                return true;
            case "playbackstart":
                obj.playbackStart = value;
                return true;
            case "displayduration":
                obj.displayDuration = value;
                return true;
            case "playbackduration":
                obj.playbackDuration = value;
                return true;
            case "dynamics":
                obj.dynamics = isNaN(parseInt(value)) ? DynamicValue[Object.keys(DynamicValue).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof DynamicValue] : parseInt(value);
                return true;
            case "invertbeamdirection":
                obj.invertBeamDirection = value;
                return true;
            case "preferredbeamdirection":
                obj.preferredBeamDirection = value === null ? null : isNaN(parseInt(value)) ? BeamDirection[Object.keys(BeamDirection).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof BeamDirection] : parseInt(value);
                return true;
            case "iseffectslurorigin":
                obj.isEffectSlurOrigin = value;
                return true;
            case "beamingmode":
                obj.beamingMode = isNaN(parseInt(value)) ? BeatBeamingMode[Object.keys(BeatBeamingMode).find($k => $k.toLowerCase() === value.toLowerCase()) as keyof typeof BeatBeamingMode] : parseInt(value);
                return true;
        } 
        return false; 
    }
}

