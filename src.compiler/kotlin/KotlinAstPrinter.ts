import * as cs from '../csharp/CSharpAst';
import * as ts from 'typescript';
import * as path from 'path';
import * as fs from 'fs';
import CSharpEmitterContext from '../csharp/CSharpEmitterContext';

export default class KotlinAstPrinter {
    private _sourceFile: cs.SourceFile;
    private _fileHandle!: number;
    private _isStartOfLine: boolean = true;
    private _indent: number = 0;
    private _context: CSharpEmitterContext;
    private _forceInteger: boolean = false;
    public diagnostics: ts.Diagnostic[] = [];

    public constructor(sourceFile: cs.SourceFile, context: CSharpEmitterContext) {
        this._sourceFile = sourceFile;
        if (sourceFile.fileName.endsWith('.cs')) {
            sourceFile.fileName = sourceFile.fileName.substr(0, sourceFile.fileName.length - 3) + '.kt';
        }
        this._context = context;
    }

    public print() {
        fs.mkdirSync(path.dirname(this._sourceFile.fileName), { recursive: true });
        this._fileHandle = fs.openSync(this._sourceFile.fileName, 'w');
        try {
            this.writeSourceFile(this._sourceFile);
        } finally {
            fs.closeSync(this._fileHandle);
        }
    }

    private writeSourceFile(sourceFile: cs.SourceFile) {
        this.writeLine('// <auto-generated>');
        this.writeLine('// This code was auto-generated.');
        this.writeLine('// Changes to this file may cause incorrect behavior and will be lost if');
        this.writeLine('// the code is regenerated.');
        this.writeLine('// </auto-generated>');
        this.writeLine();
        this.writeLine('@file:Suppress(');
        this.writeLine('    "RedundantVisibilityModifier",');
        this.writeLine('    "RedundantExplicitType",');
        this.writeLine('    "RedundantUnitReturnType",');
        this.writeLine('    "RemoveRedundantQualifierName",');
        this.writeLine('    "RemoveExplicitTypeArguments",');
        this.writeLine('    "MemberVisibilityCanBePrivate",');
        this.writeLine('    "MoveLambdaOutsideParentheses",');
        this.writeLine('    "ConvertSecondaryConstructorToPrimary",');
        this.writeLine('    "RemoveRedundantCallsOfConversionMethods",');
        this.writeLine('    "MayBeConstant",');
        this.writeLine('    "UnusedImport",');
        this.writeLine('    "CanBeVal",');
        this.writeLine('    "CascadeIf",');
        this.writeLine('    "unused",');
        this.writeLine('    "NON_EXHAUSTIVE_WHEN",');
        this.writeLine('    "UNCHECKED_CAST",');
        this.writeLine('    "UNNECESSARY_NOT_NULL_ASSERTION"');
        this.writeLine(')');
        this.writeLine(`package ${sourceFile.namespace.namespace}`);

        for (const using of sourceFile.usings) {
            this.writeImport(using);
        }
        if (sourceFile.usings.length > 0) {
            this.writeLine();
        }

        for (const declaration of sourceFile.namespace.declarations) {
            if (!declaration.skipEmit) {
                switch (declaration.nodeType) {
                    case cs.SyntaxKind.ClassDeclaration:
                        this.writeClassDeclaration(declaration as cs.ClassDeclaration);
                        break;
                    case cs.SyntaxKind.EnumDeclaration:
                        this.writeEnumDeclaration(declaration as cs.EnumDeclaration);
                        break;
                    case cs.SyntaxKind.InterfaceDeclaration:
                        this.writeInterfaceDeclaration(declaration as cs.InterfaceDeclaration);
                        break;
                }
            }
        }
    }

    private writeDocumentation(d: cs.DocumentedElement) {
        if (d.documentation) {
            this.writeLine('/**');
            this.writeDocumentationLines(d.documentation, true);
            this.writeLine(' */');
        }
    }
    private writeDocumentationLines(documentation: string, multiLine: boolean) {
        const lines = documentation.split('\n');
        if (lines.length > 1 || multiLine) {
            if (!this._isStartOfLine) {
                this.writeLine();
            }
            for (const line of lines) {
                this.writeLine(` * ${this.escapeXmlDoc(line)}`);
            }
        } else if (lines.length === 1) {
            if (this._isStartOfLine) {
                this.writeLine(` * ${this.escapeXmlDoc(lines[0])}`);
            } else {
                this.write(this.escapeXmlDoc(lines[0]));
            }
        }
    }
    private escapeXmlDoc(s: string): string {
        return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    private writeParameters(parameters: cs.ParameterDeclaration[]) {
        this.write('(');
        this.writeCommaSeparated(parameters, p => this.writeParameter(p));
        this.write(')');
    }
    private writeCommaSeparated<T>(values: T[], write: (p: T) => void) {
        values.forEach((v, i) => {
            if (i > 0) {
                this.write(', ');
            }
            write(v);
        });
    }

    private writeParameter(p: cs.ParameterDeclaration) {
        if (p.params) {
            this.write('vararg ');
        }

        this.write(`${p.name}`);
        if (p.type) {
            this.write(': ');
            if (p.params) {
                this.writeType((p.type as cs.ArrayTypeNode).elementType, false, false);
            } else {
                this.writeType(p.type, false);
            }
        }
        if (p.initializer) {
            this.write(' = ');
            this.writeExpression(p.initializer);
        } else if (p.type && p.type.isOptional) {
            if (p.type.nodeType === cs.SyntaxKind.PrimitiveTypeNode) {
                switch ((p.type as cs.PrimitiveTypeNode).type) {
                    case cs.PrimitiveType.Bool:
                        this.write(' = false');
                        break;
                    case cs.PrimitiveType.Double:
                        this.write(' = 0.0');
                        break;
                    case cs.PrimitiveType.Int:
                        this.write(' = 0');
                        break;
                    default:
                        this.write(' = null');
                        break;
                }
            } else {
                this.write(' = null');
            }
        }
    }

    private writeInterfaceDeclaration(d: cs.InterfaceDeclaration) {
        this.writeDocumentation(d);
        this.writeVisibility(d.visibility);

        if (d.partial) {
            this.write('partial ');
        }

        this.write(`interface ${d.name}`);
        this.writeTypeParameters(d.typeParameters);

        if (d.interfaces && d.interfaces.length > 0) {
            this.write(': ');
            this.writeCommaSeparated(d.interfaces, i => this.writeType(i));
        }

        this.writeTypeParameterConstraints(d.typeParameters);
        this.writeLine();
        this.beginBlock();

        d.members.forEach(m => this.writeMember(m));

        this.endBlock();
    }

    private writeEnumDeclaration(d: cs.EnumDeclaration) {
        this.writeDocumentation(d);
        this.writeVisibility(d.visibility);
        this.write(`enum class ${d.name}(override val value: Int): alphaTab.core.IAlphaTabEnum`);
        this.writeLine();
        this.beginBlock();

        let currentEnumValue = 0;

        this._forceInteger = true;
        for (let i = 0; i < d.members.length; i++) {
            let m = d.members[i];
            this.writeDocumentation(m);
            this.write(m.name);
            if (m.initializer) {
                this.write('(');
                this.writeExpression(m.initializer);
                this.write(')');
            } else {
                this.write('(');
                this.write(currentEnumValue.toString());
                this.write(')');
            }

            if (i < d.members.length - 1) {
                this.writeLine(',');
            } else {
                this.writeLine(';');
            }

            currentEnumValue++;
        }
        this._forceInteger = false;
        this.endBlock();
    }

    private writeClassDeclaration(d: cs.ClassDeclaration) {
        this.writeDocumentation(d);
        this.writeAttributes(d);
        this.writeLine('@kotlin.contracts.ExperimentalContracts');
        this.writeVisibility(d.visibility);

        if (d.isAbstract) {
            this.write('abstract ');
        } else {
            this.write('open ');
        }

        this.write(`class ${d.name}`);
        this.writeTypeParameters(d.typeParameters);

        if (d.baseClass) {
            this.write(': ');
            this.writeType(d.baseClass);
            if (!d.members.find(m => m.nodeType === cs.SyntaxKind.ConstructorDeclaration)) {
                this.write('()');
            }
        }

        if (d.interfaces && d.interfaces.length > 0) {
            if (d.baseClass) {
                this.write(', ');
            } else {
                this.write(': ');
            }

            this.writeCommaSeparated(d.interfaces, i => this.writeType(i));
        }
        this.writeTypeParameterConstraints(d.typeParameters);

        this.writeLine();

        this.beginBlock();

        let hasConstuctor = false;
        let statics: cs.ClassMember[] = [];
        d.members.forEach(m => {
            if ('isStatic' in m && m.isStatic) {
                statics.push(m);
            } else {
                this.writeMember(m);
                if (m.nodeType === cs.SyntaxKind.ConstructorDeclaration && !(m as cs.ConstructorDeclaration).isStatic) {
                    hasConstuctor = true;
                }
            }
        });

        if (statics.length > 0) {
            this.write('companion object');
            this.beginBlock();

            statics.forEach(s => {
                this.writeMember(s);
            });

            this.endBlock();
        }

        if (d.baseClass && !hasConstuctor) {
            let baseClass: cs.TypeReferenceType | undefined = d;
            let constructorDeclaration: cs.ConstructorDeclaration | undefined = undefined;
            while (baseClass && !constructorDeclaration) {
                if (typeof baseClass === 'string') {
                    constructorDeclaration = undefined;
                    break;
                } else if (baseClass.nodeType === cs.SyntaxKind.ClassDeclaration) {
                    const baseClassDeclaration = baseClass as cs.ClassDeclaration;
                    constructorDeclaration = baseClassDeclaration.members.find(
                        m => m.nodeType === cs.SyntaxKind.ConstructorDeclaration
                    ) as cs.ConstructorDeclaration;
                    if (constructorDeclaration) {
                        break;
                    }

                    baseClass =
                        baseClassDeclaration.baseClass &&
                        baseClassDeclaration.baseClass.nodeType === cs.SyntaxKind.TypeReference
                            ? (baseClassDeclaration.baseClass as cs.TypeReference).reference
                            : undefined;
                } else {
                    constructorDeclaration = undefined;
                    break;
                }
            }

            if (constructorDeclaration) {
                const defaultConstructor = {
                    parent: d,
                    name: '',
                    nodeType: cs.SyntaxKind.ConstructorDeclaration,
                    isStatic: false,
                    parameters: [],
                    visibility: cs.Visibility.Public,
                    body: {
                        parent: null,
                        nodeType: cs.SyntaxKind.Block,
                        statements: [],
                        tsNode: d.tsNode
                    } as cs.Block,
                    tsNode: d.tsNode,
                    baseConstructorArguments: []
                } as cs.ConstructorDeclaration;
                defaultConstructor.body!.parent = defaultConstructor;
                defaultConstructor.parameters = constructorDeclaration.parameters;
                defaultConstructor.baseConstructorArguments = constructorDeclaration.parameters.map(
                    p =>
                        ({
                            parent: defaultConstructor,
                            nodeType: cs.SyntaxKind.Identifier,
                            text: p.name,
                            tsNode: defaultConstructor.tsNode
                        } as cs.Identifier)
                );
                this.writeMember(defaultConstructor);
            }
        }

        this.endBlock();
    }

    public writeAttributes(d: cs.AttributedElement) {
        if (d.attributes) {
            d.attributes.forEach(a => this.writeAttribute(a));
        }
    }

    public writeAttribute(a: cs.Attribute): void {
        this.write('@');
        this.writeType(a.type);
        if (a.arguments && a.arguments.length > 0) {
            this.write('(');
            this.writeCommaSeparated(a.arguments!, x => this.writeExpression(x));
            this.write(')');
        }
        this.writeLine(']');
    }

    private writeMember(member: cs.Node) {
        if (member.skipEmit) {
            return;
        }

        switch (member.nodeType) {
            case cs.SyntaxKind.FieldDeclaration:
                this.writeFieldDeclarat1on(member as cs.FieldDeclaration);
                break;
            case cs.SyntaxKind.PropertyDeclaration:
                this.writePropertyDeclaration(member as cs.PropertyDeclaration);
                break;
            case cs.SyntaxKind.ConstructorDeclaration:
                this.writeConstructorDeclaration(member as cs.ConstructorDeclaration);
                break;
            case cs.SyntaxKind.MethodDeclaration:
                this.writeMethodDeclaration(member as cs.MethodDeclaration);
                break;
            case cs.SyntaxKind.ClassDeclaration:
                this.writeClassDeclaration(member as cs.ClassDeclaration);
                break;
            case cs.SyntaxKind.EnumDeclaration:
                this.writeEnumDeclaration(member as cs.EnumDeclaration);
                break;
            case cs.SyntaxKind.InterfaceDeclaration:
                this.writeInterfaceDeclaration(member as cs.InterfaceDeclaration);
                break;
        }
        this.writeLine();
    }

    private writeMethodDeclaration(d: cs.MethodDeclaration) {
        this.writeDocumentation(d);
        for (const p of d.parameters) {
            if (p.documentation) {
                this.write(`/// <param name="${p.name}">`);
                this.writeDocumentationLines(p.documentation, false);
                if (this._isStartOfLine) {
                    this.write('/// ');
                }
                this.writeLine('</param>');
            }
        }

        this.writeAttributes(d);
        this.writeVisibility(d.visibility);

        if (d.isAsync) {
            this.write('async ');
        }

        if (d.isAbstract) {
            this.write('abstract ');
        }

        if (d.isVirtual) {
            this.write('open ');
        }

        if (d.isOverride) {
            this.write('override ');
        }

        this.write(`fun `);
        this.writeTypeParameters(d.typeParameters);
        this.write(d.name);
        this.writeParameters(d.parameters);

        this.write(': ');
        if (d.isAsync) {
            if (
                d.returnType.nodeType === cs.SyntaxKind.PrimitiveTypeNode &&
                (d.returnType as cs.PrimitiveTypeNode).type === cs.PrimitiveType.Void
            ) {
                this.write('Deferred');
            } else {
                this.write('Deferred<');
                this.writeType(d.returnType);
                this.write('>');
            }
        } else {
            this.writeType(d.returnType);
        }

        this.writeTypeParameterConstraints(d.typeParameters);

        this.writeBody(d.body);
    }

    private writeTypeParameterConstraints(typeParameters: cs.TypeParameterDeclaration[] | undefined) {
        if (typeParameters) {
            this._indent++;
            typeParameters.forEach(p => {
                if (p.constraint) {
                    this.writeLine();
                    this.write('where ');
                    this.write(p.name);
                    this.write(' : ');
                    this.writeType(p.constraint, false, false, true);
                }
            });
            this._indent--;
        }
    }

    private writeBody(body: cs.Expression | cs.Block | undefined) {
        if (body) {
            if (body.nodeType === cs.SyntaxKind.Block) {
                this.writeLine();
                this.writeBlock(body as cs.Block);
            } else {
                this.write(' = ');
                this.writeExpression(body as cs.Expression);
                this.writeLine();
            }
        } else {
            this.writeLine();
        }
    }

    private writeConstructorDeclaration(d: cs.ConstructorDeclaration) {
        this.writeDocumentation(d);
        this.writeVisibility(d.visibility);
        if (d.isStatic) {
            this.write('init ');
        } else {
            this.write(`constructor`);
            this.writeParameters(d.parameters);
            if (d.baseConstructorArguments) {
                this.writeLine();
                this._indent++;
                this.write(': super(');
                this.writeCommaSeparated(d.baseConstructorArguments, e => this.writeExpression(e));
                this.write(')');
                this._indent--;
            }
        }

        if (d.body?.nodeType !== cs.SyntaxKind.Block || (d.body as cs.Block).statements.length > 0) {
            this.writeBody(d.body);
        }
    }

    private writePropertyDeclaration(d: cs.PropertyDeclaration) {
        this.writeDocumentation(d);

        this.writeVisibility(d.visibility);

        const isAutoProperty = this.isAutoProperty(d);
        const isLateInit = this.isLateInit(d);

        const writeAsField = this.writePropertyAsField(d);

        if (d.isVirtual) {
            this.write('open ');
        }

        if (writeAsField && this.canBeConstant(d)) {
            this.write('val ');
        } else {
            if (d.isAbstract) {
                this.write('abstract ');
            }

            if (d.isOverride) {
                this.write('override ');
            }

            if (isLateInit) {
                this.write('lateinit ');
            }

            if (
                (!isAutoProperty && !d.setAccessor) ||
                (d.isAbstract && !d.setAccessor) ||
                (d.parent!.nodeType === cs.SyntaxKind.InterfaceDeclaration && !d.setAccessor)
            ) {
                this.write('val ');
            } else {
                this.write('var ');
            }
        }

        this.write(`${d.name}: `);
        this.writeType(d.type);

        if (d.initializer && !isLateInit) {
            this.write(' = ');
            this.writeExpression(d.initializer);
            this.writeLine();
        } else if (writeAsField) {
            this.writeLine();
        }

        if (!writeAsField && !isAutoProperty) {
            this.writeLine();

            if (d.getAccessor) {
                this.writePropertyAccessor(d.getAccessor);
            }

            if (d.setAccessor) {
                this.writePropertyAccessor(d.setAccessor);
            }
        }
    }
    private isLateInit(d: cs.PropertyDeclaration) {
        return (
            d.initializer &&
            d.initializer.nodeType === cs.SyntaxKind.NonNullExpression &&
            (d.initializer as cs.NonNullExpression).expression.nodeType === cs.SyntaxKind.NullLiteral
        );
    }

    private isAutoProperty(d: cs.PropertyDeclaration) {
        if (d.getAccessor && d.getAccessor.body) {
            return false;
        }
        if (d.setAccessor && d.setAccessor.body) {
            return false;
        }
        return true;
    }

    private canBeConstant(d: cs.PropertyDeclaration): boolean {
        return (
            d.isStatic &&
            !d.setAccessor &&
            d.type.nodeType === cs.SyntaxKind.PrimitiveTypeNode &&
            !!d.initializer &&
            (!d.getAccessor || !d.getAccessor.body)
        );
    }

    private writePropertyAsField(d: cs.PropertyDeclaration) {
        if (
            d.parent!.nodeType === cs.SyntaxKind.ClassDeclaration &&
            d.visibility === cs.Visibility.Private &&
            (!d.getAccessor || !d.getAccessor.body)
        ) {
            return true;
        }
        return this.canBeConstant(d);
    }

    private writePropertyAccessor(accessor: cs.PropertyAccessorDeclaration) {
        this.write(accessor.keyword);
        if (accessor.keyword === 'set') {
            this.write('(value)');
        } else {
            this.write('()');
        }
        this.writeBody(accessor.body);
    }

    private writeFieldDeclarat1on(d: cs.FieldDeclaration) {
        this.writeDocumentation(d);
        this.writeVisibility(d.visibility);

        if (this._context.isConst(d)) {
            this.write('const ');
        } else {
            if (d.isReadonly) {
                this.write('readonly ');
            }
        }

        this.writeType(d.type);
        this.write(` ${d.name}`);
        if (d.initializer) {
            this.write(' = ');
            this.writeExpression(d.initializer);
        }
        this.writeLine();
    }

    private writeType(
        type: cs.TypeNode,
        forNew: boolean = false,
        asNativeArray: boolean = false,
        forTypeConstraint: boolean = false
    ) {
        switch (type.nodeType) {
            case cs.SyntaxKind.PrimitiveTypeNode:
                if (forTypeConstraint) {
                    switch ((type as cs.PrimitiveTypeNode).type) {
                        case cs.PrimitiveType.Bool:
                        case cs.PrimitiveType.Int:
                        case cs.PrimitiveType.Double:
                            this.write('struct');
                            break;
                        case cs.PrimitiveType.Object:
                        case cs.PrimitiveType.Dynamic:
                        case cs.PrimitiveType.String:
                        case cs.PrimitiveType.Void:
                            this.write('class');
                            break;
                    }
                } else {
                    switch ((type as cs.PrimitiveTypeNode).type) {
                        case cs.PrimitiveType.Bool:
                            this.write('Boolean');
                            break;
                        case cs.PrimitiveType.Dynamic:
                            this.write('Any');
                            break;
                        case cs.PrimitiveType.Double:
                            this.write(this._forceInteger ? 'Int' : 'Double');
                            break;
                        case cs.PrimitiveType.Int:
                            this.write('Int');
                            break;
                        case cs.PrimitiveType.Object:
                            this.write('Any');
                            break;
                        case cs.PrimitiveType.String:
                            this.write('String');
                            break;
                        case cs.PrimitiveType.Void:
                            this.write('Unit');
                            break;
                        case cs.PrimitiveType.Var:
                            this.write('var');
                            break;
                    }
                }

                break;
            case cs.SyntaxKind.ArrayTypeNode:
                const arrayType = type as cs.ArrayTypeNode;
                if (asNativeArray) {
                    this.write('Array<');
                    this.writeType(arrayType.elementType);
                    this.write('>');
                } else {
                    const isDynamicArray =
                        arrayType.elementType.nodeType == cs.SyntaxKind.PrimitiveTypeNode &&
                        (arrayType.elementType as cs.PrimitiveTypeNode).type == cs.PrimitiveType.Dynamic;
                    if (isDynamicArray && !forNew) {
                        this.write('kotlin.collections.MutableList');
                    } else {
                        if (forNew) {
                            this.write('kotlin.collections.ArrayList<');
                        } else {
                            this.write('kotlin.collections.MutableList<');
                        }
                        this.writeType(arrayType.elementType);
                        this.write('>');
                    }
                }

                break;
            case cs.SyntaxKind.FunctionTypeNode:
                const functionType = type as cs.FunctionTypeNode;
                this.write('(');
                if (functionType.parameterTypes.length > 0) {
                    let i = 1;
                    this.writeCommaSeparated(functionType.parameterTypes, p => {
                        this.write(`arg${i++}: `);
                        this.writeType(p);
                    });
                }
                this.write(') -> ');
                this.writeType(functionType.returnType);
                break;
            case cs.SyntaxKind.TypeReference:
                const typeReference = type as cs.TypeReference;
                const targetType = (type as cs.TypeReference).reference;
                if (typeof targetType === 'string') {
                    this.write(targetType);
                } else {
                    this.writeType(targetType, forNew);
                }

                if (typeReference.typeArguments && typeReference.typeArguments.length > 0) {
                    this.write('<');
                    this.writeCommaSeparated(typeReference.typeArguments, p => this.writeType(p));
                    this.write('>');
                }
                break;
            case cs.SyntaxKind.ClassDeclaration:
            case cs.SyntaxKind.InterfaceDeclaration:
            case cs.SyntaxKind.EnumDeclaration:
                this.write(this._context.getFullName(type as cs.NamedTypeDeclaration));
                break;
            case cs.SyntaxKind.TypeParameterDeclaration:
                this.write((type as cs.TypeParameterDeclaration).name);
                break;
            case cs.SyntaxKind.EnumMember:
                this.write(this._context.getFullName((type as cs.EnumMember).parent as cs.NamedTypeDeclaration));
                break;
            default:
                this.write('TODO: ' + cs.SyntaxKind[type.nodeType]);
                break;
        }
        if (type.isNullable && !forNew && !forTypeConstraint) {
            this.write('?');
        }
    }

    private writeTypeParameters(typeParameters: cs.TypeParameterDeclaration[] | undefined) {
        if (typeParameters && typeParameters.length > 0) {
            this.write('<');
            typeParameters.forEach((p, i) => {
                if (i > 0) {
                    this.write(', ');
                }
                this.writeTypeParameter(p);
            });
            this.write('> ');
        }
    }

    private writeTypeParameter(p: cs.TypeParameterDeclaration) {
        this.write(p.name);
    }

    private writeExpression(expr: cs.Expression) {
        switch (expr.nodeType) {
            case cs.SyntaxKind.PrefixUnaryExpression:
                this.writePrefixUnaryExpression(expr as cs.PrefixUnaryExpression);
                break;
            case cs.SyntaxKind.PostfixUnaryExpression:
                this.writePostfixUnaryExpression(expr as cs.PostfixUnaryExpression);
                break;
            case cs.SyntaxKind.NullLiteral:
                this.writeNullLiteral(expr as cs.NullLiteral);
                break;
            case cs.SyntaxKind.FalseLiteral:
            case cs.SyntaxKind.TrueLiteral:
                this.writeBooleanLiteral(expr as cs.BooleanLiteral);
                break;
            case cs.SyntaxKind.ThisLiteral:
                this.writeThisLiteral(expr as cs.ThisLiteral);
                break;
            case cs.SyntaxKind.BaseLiteralExpression:
                this.writeBaseLiteralExpression(expr as cs.BaseLiteralExpression);
                break;
            case cs.SyntaxKind.StringLiteral:
                this.writeStringLiteral(expr as cs.StringLiteral);
                break;
            case cs.SyntaxKind.AwaitExpression:
                this.writeAwaitExpression(expr as cs.AwaitExpression);
                break;
            case cs.SyntaxKind.BinaryExpression:
                this.writeBinaryExpression(expr as cs.BinaryExpression);
                break;
            case cs.SyntaxKind.ConditionalExpression:
                this.writeConditionalExpression(expr as cs.ConditionalExpression);
                break;
            case cs.SyntaxKind.LambdaExpression:
                this.writeLambdaExpression(expr as cs.LambdaExpression);
                break;
            case cs.SyntaxKind.NumericLiteral:
                this.writeNumericLiteral(expr as cs.NumericLiteral);
                break;
            case cs.SyntaxKind.StringTemplateExpression:
                this.writeStringTemplateExpression(expr as cs.StringTemplateExpression);
                break;
            case cs.SyntaxKind.IsExpression:
                this.writeIsExpression(expr as cs.IsExpression);
                break;
            case cs.SyntaxKind.ParenthesizedExpression:
                this.writeParenthesizedExpression(expr as cs.ParenthesizedExpression);
                break;
            case cs.SyntaxKind.ArrayCreationExpression:
                this.writeArrayCreationExpression(expr as cs.ArrayCreationExpression);
                break;
            case cs.SyntaxKind.MemberAccessExpression:
                this.writeMemberAccessExpression(expr as cs.MemberAccessExpression);
                break;
            case cs.SyntaxKind.AnonymousObjectCreationExpression:
                this.writeAnonymousObjectCreationExpression(expr as cs.AnonymousObjectCreationExpression);
                break;
            case cs.SyntaxKind.AnonymousObjectProperty:
                this.writeAnonymousObjectProperty(expr as cs.AnonymousObjectProperty);
                break;
            case cs.SyntaxKind.ElementAccessExpression:
                this.writeElementAccessExpression(expr as cs.ElementAccessExpression);
                break;
            case cs.SyntaxKind.InvocationExpression:
                this.writeInvocationExpression(expr as cs.InvocationExpression);
                break;
            case cs.SyntaxKind.NewExpression:
                this.writeNewExpression(expr as cs.NewExpression);
                break;
            case cs.SyntaxKind.CastExpression:
                this.writeCastExpression(expr as cs.CastExpression);
                break;
            case cs.SyntaxKind.NonNullExpression:
                this.writeNonNullExpression(expr as cs.NonNullExpression);
                break;
            case cs.SyntaxKind.NullSafeExpression:
                this.writeNullSafeExpression(expr as cs.NullSafeExpression);
                break;
            case cs.SyntaxKind.Identifier:
                this.writeIdentifier(expr as cs.Identifier);
                break;
            case cs.SyntaxKind.ToDoExpression:
                this.writeToDoExpression(expr as cs.ToDoExpression);
                break;
            case cs.SyntaxKind.DefaultExpression:
                this.writeDefaultExpression(expr as cs.DefaultExpression);
                break;
            case cs.SyntaxKind.TypeOfExpression:
                this.writeTypeOfExpression(expr as cs.TypeOfExpression);
                break;
            default:
                throw new Error(`Unhandled expression type: ${cs.SyntaxKind[expr.nodeType]}`);
        }
    }
    private writeDefaultExpression(expr: cs.DefaultExpression) {
        this.write('default');
        if (expr.type) {
            this.write('(');
            this.writeType(expr.type);
            this.write(')');
        }
    }

    private writeTypeOfExpression(expr: cs.TypeOfExpression) {
        if (expr.expression) {
            this.writeExpression(expr.expression);
            this.write('::class');
        }
    }

    private writePrefixUnaryExpression(expr: cs.PrefixUnaryExpression) {
        switch (expr.operator) {
            case '~':
                this.write('(');
                this.writeExpression(expr.operand);
                this.write(').toInt().inv()');
                break;
            default:
                this.write(expr.operator);
                this.writeExpression(expr.operand);
                break;
        }
    }

    private writePostfixUnaryExpression(expr: cs.PostfixUnaryExpression) {
        this.writeExpression(expr.operand);
        this.write(expr.operator);
    }

    private writeNullLiteral(expr: cs.NullLiteral) {
        this.write('null');
    }

    private writeBooleanLiteral(expr: cs.BooleanLiteral) {
        this.write(expr.nodeType === cs.SyntaxKind.TrueLiteral ? 'true' : 'false');
    }

    private writeThisLiteral(expr: cs.ThisLiteral) {
        this.write('this');
    }

    private writeBaseLiteralExpression(expr: cs.BaseLiteralExpression) {
        this.write('base');
    }

    private writeStringLiteral(expr: cs.StringLiteral) {
        this.write(JSON.stringify(expr.text));
    }

    private writeAwaitExpression(expr: cs.AwaitExpression) {
        this.write('await ');
        this.writeExpression(expr.expression);
    }

    private writeBinaryExpression(expr: cs.BinaryExpression) {
        this.writeExpression(expr.left);
        this.write(' ');
        switch (expr.operator) {
            case '??':
                this.write('?:');
                break;
            case '&':
                this.write('and');
                break;
            case '|':
                this.write('or');
                break;
            case '^':
                this.write('xor');
                break;
            case '<<':
                this.write('shl');
                break;
            case '>>':
                this.write('shr');
                break;
            default:
                this.write(expr.operator);
                break;
        }
        this.write(' ');
        this.writeExpression(expr.right);
    }

    private writeConditionalExpression(expr: cs.ConditionalExpression) {
        this.write('if(');
        this.writeExpression(expr.condition);
        this.write(')  ');
        this.writeExpression(expr.whenTrue);
        this.write(' else ');
        this.writeExpression(expr.whenFalse);
    }

    private writeLambdaExpression(expr: cs.LambdaExpression) {
        this.write('fun(');
        this.writeCommaSeparated(expr.parameters, p => this.writeParameter(p));
        this.write('): ');
        this.writeType(expr.returnType);
        if (expr.body.nodeType === cs.SyntaxKind.Block) {
            this.writeBlock(expr.body as cs.Block);
        } else {
            this.beginBlock();
            this.write('return ');
            this.writeExpression(expr.body);
            this.writeLine();
            this.endBlock();
        }
    }

    private shouldWriteDoubleSuffix(expr: cs.Expression) {
        let shouldWriteSuffix = false;
        if (!this._forceInteger && expr.parent) {
            shouldWriteSuffix =
                expr.nodeType === cs.SyntaxKind.NumericLiteral
                    ? (expr as cs.NumericLiteral).value.indexOf('.') === -1
                    : false;

            switch (expr.parent.nodeType) {
                case cs.SyntaxKind.VariableDeclaration:
                    if (
                        expr.parent.parent?.nodeType === cs.SyntaxKind.VariableDeclarationList &&
                        expr.parent.parent.parent?.nodeType === cs.SyntaxKind.ForStatement &&
                        expr.parent.parent === (expr.parent.parent.parent as cs.ForStatement).initializer
                    ) {
                        shouldWriteSuffix = false;
                    }
                    break;
                case cs.SyntaxKind.ParenthesizedExpression:
                    shouldWriteSuffix = this.shouldWriteDoubleSuffix(expr.parent!.parent!);
                    break;
                case cs.SyntaxKind.PropertyDeclaration:
                case cs.SyntaxKind.FieldDeclaration:
                case cs.SyntaxKind.VariableDeclaration:
                case cs.SyntaxKind.ConditionalExpression:
                    break;
                case cs.SyntaxKind.PrefixUnaryExpression:
                    switch ((expr.parent as cs.PrefixUnaryExpression).operator) {
                        case '~':
                            shouldWriteSuffix = false;
                            break;
                    }
                    break;
                case cs.SyntaxKind.BinaryExpression:
                    const bin = expr.parent as cs.BinaryExpression;
                    switch (bin.operator) {
                        case '<<':
                        case '>>':
                        case '<':
                        case '>':
                        case '<=':
                        case '>=':
                        case '|':
                        case '^':
                        case '&':
                        case '|=':
                        case '^=':
                        case '&=':
                            shouldWriteSuffix = false;
                            break;
                        case '==':
                        case '!=':
                            const otherExpr = bin.left == expr ? bin.right : bin.left;
                            shouldWriteSuffix = !this.isIntResultExpression(otherExpr);
                            break;
                    }
                    break;
            }
        }

        return shouldWriteSuffix;
    }

    private writeNumericLiteral(expr: cs.NumericLiteral) {
        this.write(expr.value);

        if (this.shouldWriteDoubleSuffix(expr)) {
            this.write('.0');
        }
    }
    private isIntResultExpression(expr: cs.Expression): boolean {
        if (expr.nodeType === cs.SyntaxKind.MemberAccessExpression) {
            const parentSymbol = (expr.tsSymbol as any).parent as ts.Symbol;
            switch (parentSymbol.name) {
                case 'Array':
                    switch (expr.tsSymbol!.name) {
                        case 'indexOf':
                            return true;
                    }
                    return false;
                case 'String':
                    switch (expr.tsSymbol!.name) {
                        case 'length':
                            return true;
                    }
                    return false;
            }
            return false;
        } else if (expr.nodeType === cs.SyntaxKind.InvocationExpression) {
            return this.isIntResultExpression((expr as cs.InvocationExpression).expression);
        } else if (expr.nodeType === cs.SyntaxKind.BinaryExpression) {
            switch ((expr as cs.BinaryExpression).operator) {
                case '<<':
                case '>>':
                case '&':
                case '|':
                case '^':
                    return true;
            }
            return false;
        } else if (expr.nodeType === cs.SyntaxKind.ParenthesizedExpression) {
            return this.isIntResultExpression((expr as cs.ParenthesizedExpression).expression);
        } else {
            return false;
        }
    }

    private writeStringTemplateExpression(expr: cs.StringTemplateExpression) {
        this.write('"');
        let exprs: cs.Expression[] = [];
        expr.chunks.forEach(c => {
            if (c.nodeType === cs.SyntaxKind.StringLiteral) {
                const escapedText = (c as cs.StringLiteral).text
                    .split('"')
                    .join('""')
                    .split('\n')
                    .join('\\n')
                    .split('\r')
                    .join('\\r');
                this.write(escapedText);
            } else {
                this.write('${');
                this.writeExpression(c as cs.Expression);
                this.write('}');
            }
        });
        this.write('"');
    }

    private writeIsExpression(expr: cs.IsExpression) {
        this.writeExpression(expr.expression);
        this.write(' is ');
        this.writeType(expr.type);
    }

    private writeParenthesizedExpression(expr: cs.ParenthesizedExpression) {
        this.write('(');
        this.writeExpression(expr.expression);
        this.write(')');
    }

    private writeArrayCreationExpression(expr: cs.ArrayCreationExpression) {
        if (expr.type) {
            if (expr.values) {
                this.write('arrayListOf');
                if (expr.type && expr.type.nodeType == cs.SyntaxKind.ArrayTypeNode) {
                    this.write('<');
                    this.writeType((expr.type as cs.ArrayTypeNode).elementType);
                    this.write('>');
                }
                this.writeLine('(');
                this._indent++;
                this.writeCommaSeparated(expr.values, v => {
                    if (expr.values!.length > 10) {
                        this.writeLine();
                    }
                    this.writeExpression(v);
                });
                this._indent--;
                this.writeLine(')');
            } else {
                this.writeType(expr.type, true);
                this.write('(');
                this.writeExpression(expr.sizeExpression!);
                this.write(')');
            }
        } else if (expr.values && expr.values.length > 0) {
            this.write('arrayListOf(');
            this.writeCommaSeparated(expr.values, v => {
                if (expr.values!.length > 10) {
                    this.writeLine();
                }
                this.writeExpression(v);
            });
            this.write(')');
        } else {
            this._context.addCsNodeDiagnostics(expr, 'Unknown array type', ts.DiagnosticCategory.Error);
        }
    }

    private writeMemberAccessExpression(expr: cs.MemberAccessExpression) {
        this.writeExpression(expr.expression);
        if (expr.nullSafe) {
            this.write('?.');
        } else if (expr.tsSymbol && this._context.isStaticSymbol(expr.tsSymbol)) {
            this.write('.');
        } else if (
            expr.expression.nodeType == cs.SyntaxKind.NonNullExpression ||
            expr.expression.nodeType === cs.SyntaxKind.Identifier ||
            expr.expression.nodeType === cs.SyntaxKind.ArrayCreationExpression ||
            expr.expression.nodeType === cs.SyntaxKind.NewExpression ||
            expr.expression.nodeType === cs.SyntaxKind.ThisLiteral
        ) {
            this.write('.');
        } else {
            this.write('!!.');
        }
        const name = this._context.getSymbolName(expr) ?? expr.member;
        this.write(name);
    }

    private writeAnonymousObjectCreationExpression(expr: cs.AnonymousObjectCreationExpression) {
        this.write('new');
        this.beginBlock();

        expr.properties.forEach(p => this.writeAnonymousObjectProperty(p));

        this.endBlock();
    }

    private writeAnonymousObjectProperty(expr: cs.AnonymousObjectProperty) {
        this.write(expr.name);
        this.write(' = ');
        this.writeExpression(expr.value);
        this.writeLine(',');
    }

    private writeElementAccessExpression(expr: cs.ElementAccessExpression) {
        this.writeExpression(expr.expression);
        if (expr.expression.nodeType !== cs.SyntaxKind.NonNullExpression) {
            this.write('!!');
        }
        this.write('[');
        this.writeExpression(expr.argumentExpression);
        this.write(']');
    }

    private writeInvocationExpression(expr: cs.InvocationExpression) {
        this.writeExpression(expr.expression);
        if (expr.typeArguments) {
            this.write('<');
            this.writeCommaSeparated(expr.typeArguments, t => this.writeType(t));
            this.write('>');
        }
        this.write('(');
        this.writeCommaSeparated(expr.arguments, a => this.writeExpression(a));
        this.write(')');
    }

    private writeNewExpression(expr: cs.NewExpression) {
        if (expr.type.nodeType == cs.SyntaxKind.ArrayTypeNode && expr.arguments.length === 1) {
            this.writeType(expr.type, true);
            this.write('( (');
            this.writeExpression(expr.arguments[0]);
            this.write(').toInt() )');
        } else {
            this.writeType(expr.type, true);
            this.write('(');
            this.writeCommaSeparated(expr.arguments, a => this.writeExpression(a));
            this.write(')');
        }
    }

    private writeCastExpression(expr: cs.CastExpression) {
        if (expr.type.nodeType === cs.SyntaxKind.PrimitiveTypeNode) {
            switch ((expr.type as cs.PrimitiveTypeNode).type) {
                case cs.PrimitiveType.String:
                    this.writeExpression(expr.expression);
                    this.write('.toString()');
                    return;
                case cs.PrimitiveType.Double:
                    this.writeExpression(expr.expression);
                    this.write('.toDouble()');
                    return;
                case cs.PrimitiveType.Int:
                    this.writeExpression(expr.expression);
                    this.write('.toInt()');
                    return;
            }
        }

        this.write('(');
        this.writeExpression(expr.expression);
        this.write(' as ');
        this.writeType(expr.type);
        this.write(')');
    }

    private writeNonNullExpression(expr: cs.NonNullExpression) {
        this.writeExpression(expr.expression);
        this.write('!!');
    }

    private writeNullSafeExpression(expr: cs.NullSafeExpression) {
        this.writeExpression(expr.expression);
        this.write('?');
    }

    private writeIdentifier(expr: cs.Identifier) {
        const name = this._context.getSymbolName(expr) ?? expr.text;
        this.write(name);
    }

    private writeToDoExpression(expr: cs.ToDoExpression) {
        this.write('/* TODO */');
    }

    private writeStatement(s: cs.Statement) {
        switch (s.nodeType) {
            case cs.SyntaxKind.EmptyStatement:
                this.writeEmptyStatement(s as cs.EmptyStatement);
                break;
            case cs.SyntaxKind.Block:
                this.writeBlock(s as cs.Block);
                break;
            case cs.SyntaxKind.VariableStatement:
                this.writeVariableStatement(s as cs.VariableStatement);
                break;
            case cs.SyntaxKind.ExpressionStatement:
                this.writeExpressionStatement(s as cs.ExpressionStatement);
                break;
            case cs.SyntaxKind.IfStatement:
                this.writeIfStatement(s as cs.IfStatement);
                break;
            case cs.SyntaxKind.DoStatement:
                this.writeDoStatement(s as cs.DoStatement);
                break;
            case cs.SyntaxKind.WhileStatement:
                this.writeWhileStatement(s as cs.WhileStatement);
                break;
            case cs.SyntaxKind.ForStatement:
                this.writeForStatement(s as cs.ForStatement);
                break;
            case cs.SyntaxKind.ForEachStatement:
                this.writeForEachStatement(s as cs.ForEachStatement);
                break;
            case cs.SyntaxKind.BreakStatement:
                this.writeBreakStatement(s as cs.BreakStatement);
                break;
            case cs.SyntaxKind.ContinueStatement:
                this.writeContinueStatement(s as cs.ContinueStatement);
                break;
            case cs.SyntaxKind.ReturnStatement:
                this.writeReturnStatement(s as cs.ReturnStatement);
                break;
            case cs.SyntaxKind.SwitchStatement:
                this.writeSwitchStatement(s as cs.SwitchStatement);
                break;
            case cs.SyntaxKind.ThrowStatement:
                this.writeThrowStatement(s as cs.ThrowStatement);
                break;
            case cs.SyntaxKind.TryStatement:
                this.writeTryStatement(s as cs.TryStatement);
                break;
        }
    }

    private writeTryStatement(s: cs.TryStatement) {
        this.writeLine('try');
        this.writeBlock(s.tryBlock);
        if (s.catchClauses) {
            s.catchClauses.forEach(c => this.writeCatchClause(c));
        }
        if (s.finallyBlock) {
            this.writeLine('finally');
            this.writeBlock(s.finallyBlock);
        }
    }

    private writeCatchClause(c: cs.CatchClause): void {
        this.write('catch (');
        this.write(c.variableDeclaration.name);
        this.write(': ');
        this.writeType(c.variableDeclaration.type);
        this.writeLine(')');
        this.writeBlock(c.block);
    }

    private writeThrowStatement(s: cs.ThrowStatement) {
        this.write('throw');
        if (s.expression) {
            this.write(' ');
            this.writeExpression(s.expression);
        }
        this.writeLine();
    }

    private writeSwitchStatement(s: cs.SwitchStatement) {
        this.write('when (');
        this.writeExpression(s.expression);
        this.writeLine(')');
        this.beginBlock();

        s.caseClauses.forEach(c => {
            if (c.nodeType === cs.SyntaxKind.DefaultClause) {
                this.writeDefaultClause(c as cs.DefaultClause);
            } else {
                this.writeCaseClause(c as cs.CaseClause);
            }
        });

        this.endBlock();
    }

    private getCaseClauseStatements(stmt: cs.Statement[]): cs.Statement[] {
        if (stmt.length === 1 && stmt[0].nodeType === cs.SyntaxKind.Block) {
            stmt = (stmt[0] as cs.Block).statements;
        }
        stmt = stmt.slice();
        if (stmt[stmt.length - 1].nodeType === cs.SyntaxKind.BreakStatement) {
            stmt.pop();
        }
        return stmt;
    }

    private writeCaseClause(c: cs.CaseClause) {
        this.writeExpression(c.expression);
        if (c.statements.length === 0) {
            this.write(', ');
            return;
        }

        this.writeLine(' -> ');
        this.beginBlock();

        this.getCaseClauseStatements(c.statements).forEach(s => this.writeStatement(s));
        this.endBlock();
    }

    private writeDefaultClause(c: cs.DefaultClause) {
        this.writeLine('else -> ');
        this.beginBlock();
        this.getCaseClauseStatements(c.statements).forEach(s => this.writeStatement(s));
        this.endBlock();
    }

    private writeReturnStatement(r: cs.ReturnStatement) {
        this.write('return');
        if (r.expression) {
            this.write(' ');
            this.writeExpression(r.expression);
        }
        this.writeLine();
    }

    private writeContinueStatement(_: cs.ContinueStatement) {
        this.writeLine('continue');
    }

    private writeBreakStatement(_: cs.BreakStatement) {
        this.writeLine('break');
    }

    private writeForEachStatement(s: cs.ForEachStatement) {
        this.write('for (');
        if (s.initializer.nodeType === cs.SyntaxKind.VariableDeclarationList) {
            const d = (s.initializer as cs.VariableDeclarationList).declarations[0];
            if (d.deconstructNames) {
                this.write('(');
                d.deconstructNames.forEach((v, i) => {
                    if (i > 0) {
                        this.write(', ');
                    }
                    this.write(v);
                });
                this.write(')');
            } else {
                this.write(d.name);
            }
        } else {
            this.writeExpression(s.initializer as cs.Expression);
        }
        this.write(' in ');
        this.writeExpression(s.expression);
        this.writeLine(')');

        if (s.statement.nodeType === cs.SyntaxKind.Block) {
            this.writeStatement(s.statement);
        } else {
            this._indent++;
            this.writeStatement(s.statement);
            this._indent--;
        }
    }

    private writeForStatement(s: cs.ForStatement) {
        let [name, lower, upper, rangeOperator] = this.detectForRange(s);
        if (lower && upper && rangeOperator) {
            this.write(`for(${name} in (`);
            this._forceInteger = true;
            this.writeExpression(lower);
            this.write(').toInt() ');
            this.write(rangeOperator);
            this.write(' (');
            this.writeExpression(upper);
            this.write(').toInt())');
            this._forceInteger = false;
            this.writeStatement(s.statement);
        } else {
            this.write('run ');
            this.beginBlock();

            this._forceInteger = true;
            if (s.initializer) {
                if (s.initializer.nodeType === cs.SyntaxKind.VariableDeclarationList) {
                    this.writeVariableDeclarationList(s.initializer as cs.VariableDeclarationList);
                } else {
                    this.writeExpression(s.initializer as cs.Expression);
                }
            }
            this._forceInteger = false;
            this.writeLine();

            this.write('while(');
            if (s.condition) {
                this.writeExpression(s.condition);
            }
            this.write(')');
            this.beginBlock();

            this.write('try');
            this.beginBlock();

            if (s.statement.nodeType === cs.SyntaxKind.Block) {
                for (const stmt of (s.statement as cs.Block).statements) {
                    this.writeStatement(stmt);
                }
            } else {
                this._indent++;
                this.writeStatement(s.statement);
                this._indent--;
            }
            this.endBlock();
            this.write('finally');
            this.beginBlock();
            if (s.incrementor) {
                this.writeExpression(s.incrementor);
                this.writeLine();
            }
            this.endBlock();
            this.endBlock();
            this.endBlock();
        }
    }

    private detectForRange(
        s: cs.ForStatement
    ): [string | null, cs.Expression | null, cs.Expression | null, string | null] {
        if (!s.initializer || !s.condition || !s.incrementor) {
            return [null, null, null, null];
        }

        // let i=0 or let i=0, j=10
        if (s.initializer.nodeType !== cs.SyntaxKind.VariableDeclarationList) {
            return [null, null, null, null];
        }

        // i < 10 or i < j or i >= 0
        if (
            s.condition.nodeType !== cs.SyntaxKind.BinaryExpression ||
            ((s.condition as cs.BinaryExpression).operator !== '<' &&
                (s.condition as cs.BinaryExpression).operator !== '>=')
        ) {
            return [null, null, null, null];
        }

        // i++ or i--
        if (
            s.incrementor.nodeType !== cs.SyntaxKind.PostfixUnaryExpression ||
            ((s.incrementor as cs.PostfixUnaryExpression).operator !== '++' &&
                (s.incrementor as cs.PostfixUnaryExpression).operator !== '--')
        ) {
            return [null, null, null, null];
        }

        const decl = s.initializer as cs.VariableDeclarationList;
        const operator = (s.condition as cs.BinaryExpression).operator === '<' ? 'until' : 'downTo';

        if (decl.declarations.length === 1) {
            const name = decl.declarations[0].name;
            const lower = decl.declarations[0].initializer;
            if (!lower) {
                return [null, null, null, null];
            }

            const left = (s.condition as cs.BinaryExpression).left;
            if (left.nodeType === cs.SyntaxKind.Identifier) {
                if ((left as cs.Identifier).text !== name) {
                    return [null, null, null, null];
                }
            } else {
                return [null, null, null, null];
            }

            const upper = (s.condition as cs.BinaryExpression).right;

            return [name, lower, upper, operator];
        } else if (decl.declarations.length === 2) {
            const lowerName = decl.declarations[0].name;
            const lower = decl.declarations[0].initializer;
            const upperName = decl.declarations[1].name;
            const upper = decl.declarations[1].initializer;
            if (!lower || !upper) {
                return [null, null, null, null];
            }

            const left = (s.condition as cs.BinaryExpression).left;
            if (left.nodeType === cs.SyntaxKind.Identifier) {
                if ((left as cs.Identifier).text !== lowerName) {
                    return [null, null, null, null];
                }
            } else {
                return [null, null, null, null];
            }

            const right = (s.condition as cs.BinaryExpression).left;
            if (right.nodeType === cs.SyntaxKind.Identifier) {
                if ((right as cs.Identifier).text !== upperName) {
                    return [null, null, null, null];
                }
            } else {
                return [null, null, null, null];
            }

            return [lowerName, lower, upper, operator];
        } else {
            return [null, null, null, null];
        }
    }

    private writeWhileStatement(s: cs.WhileStatement) {
        this.write('while (');
        this.writeExpression(s.expression);
        this.writeLine(')');
        if (s.statement.nodeType === cs.SyntaxKind.Block) {
            this.writeStatement(s.statement);
        } else {
            this._indent++;
            this.writeStatement(s.statement);
            this._indent--;
        }
    }

    private writeDoStatement(s: cs.DoStatement) {
        this.writeLine('do');
        this.writeStatement(s.statement);
        this.write('while (');
        this.writeExpression(s.expression);
        this.writeLine(');');
    }

    private writeIfStatement(s: cs.IfStatement) {
        this.write('if (');
        this.writeExpression(s.expression);
        this.writeLine(')');
        if (s.thenStatement.nodeType === cs.SyntaxKind.Block) {
            this.writeStatement(s.thenStatement);
        } else {
            this._indent++;
            this.writeStatement(s.thenStatement);
            this._indent--;
        }

        if (s.elseStatement) {
            this.write('else ');
            if (s.elseStatement.nodeType === cs.SyntaxKind.IfStatement) {
                this.writeStatement(s.elseStatement);
            } else if (s.elseStatement.nodeType === cs.SyntaxKind.Block) {
                this.writeLine();
                this.writeStatement(s.elseStatement);
            } else {
                this.writeLine();
                this._indent++;
                this.writeStatement(s.elseStatement);
                this._indent--;
            }
        }
    }
    private writeExpressionStatement(s: cs.ExpressionStatement) {
        this.writeExpression(s.expression);
        this.writeLine();
    }

    private writeVariableStatement(v: cs.VariableStatement) {
        this.writeVariableDeclarationList(v.declarationList);
        this.writeLine();
    }

    private writeVariableDeclarationList(declarationList: cs.VariableDeclarationList) {
        declarationList.declarations.forEach((d, i) => {
            this.write('var ');
            if (d.deconstructNames) {
                this.write('(');
                d.deconstructNames.forEach((v, i) => {
                    if (i > 0) {
                        this.write(', ');
                    }
                    this.write(v);
                });
                this.write(')');
            } else {
                this.write(d.name);
            }

            if (
                d.type.nodeType !== cs.SyntaxKind.PrimitiveTypeNode ||
                (d.type as cs.PrimitiveTypeNode).type !== cs.PrimitiveType.Var
            ) {
                this.write(': ');
                this.writeType(d.type);
            }

            if (d.initializer) {
                this.write(' = ');
                this.writeExpression(d.initializer);
            }

            this.writeLine();
        });
    }

    private writeEmptyStatement(_: cs.EmptyStatement) {
        this.writeLine();
    }

    private writeBlock(b: cs.Block) {
        if (b.parent?.nodeType === cs.SyntaxKind.Block) {
            this.write('run ');
        }
        this.beginBlock();
        b.statements.forEach(s => this.writeStatement(s));
        this.endBlock();
    }

    private writeVisibility(visibility: cs.Visibility) {
        switch (visibility) {
            case cs.Visibility.Public:
                this.write('public ');
                break;
            case cs.Visibility.Private:
                this.write('private ');
                break;
            case cs.Visibility.Protected:
                this.write('protected ');
                break;
            case cs.Visibility.Internal:
                this.write('internal ');
                break;
        }
    }

    private writeImport(using: cs.UsingDeclaration) {
        this.writeLine(`import ${using.namespaceOrTypeName}.*`);
    }

    private writeLine(txt?: string) {
        this.writeIndent();
        if (txt) {
            this.write(txt);
        }
        this.write(ts.sys.newLine);
        this._isStartOfLine = true;
    }

    private write(txt: string) {
        this.writeIndent();
        fs.writeSync(this._fileHandle, txt);
        this._isStartOfLine = false;
    }

    private writeIndent() {
        if (this._isStartOfLine && this._indent > 0) {
            fs.writeSync(this._fileHandle, this._indent === 1 ? '    ' : '    '.repeat(this._indent));
            this._isStartOfLine = false;
        }
    }

    private beginBlock() {
        this.writeLine('{');
        this._indent++;
    }

    private endBlock() {
        this._indent--;
        this.writeLine('}');
    }
}
