import * as path from 'path';
import * as ts from 'typescript';
import * as fs from 'fs';

export default function createEmitter(jsDocMarker: string, generate: (program: ts.Program, classDeclaration: ts.ClassDeclaration) => ts.SourceFile) {

    function generateClass(program: ts.Program, classDeclaration: ts.ClassDeclaration) {
        const sourceFileName = path.relative(
            path.resolve(program.getCompilerOptions().baseUrl!, 'src'),
            path.resolve(classDeclaration.getSourceFile().fileName)
        );

        const result = generate(program, classDeclaration);
        const defaultClass = result.statements.filter(stmt => ts.isClassDeclaration(stmt) &&
            stmt.modifiers!.find(m => m.kind === ts.SyntaxKind.ExportKeyword)
        )[0] as ts.ClassDeclaration;

        const targetFileName = path.join(
            path.resolve(program.getCompilerOptions().baseUrl!),
            'src/generated',
            path.dirname(sourceFileName),
            defaultClass.name!.text + '.ts'
        );

        fs.mkdirSync(path.dirname(targetFileName), { recursive: true });

        const fileHandle = fs.openSync(targetFileName, 'w');

        fs.writeSync(fileHandle, '// <auto-generated>\n');
        fs.writeSync(fileHandle, '// This code was auto-generated.\n');
        fs.writeSync(fileHandle, '// Changes to this file may cause incorrect behavior and will be lost if\n');
        fs.writeSync(fileHandle, '// the code is regenerated.\n');
        fs.writeSync(fileHandle, '// </auto-generated>\n');

        const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
        const source = printer.printNode(ts.EmitHint.Unspecified, result, result);
        const servicesHost: ts.LanguageServiceHost = {
            getScriptFileNames: () => [targetFileName],
            getScriptVersion: fileName => result.languageVersion.toString(),
            getScriptSnapshot: fileName => {
                if (fileName != targetFileName) {
                    return undefined;
                }

                return ts.ScriptSnapshot.fromString(source);
            },
            getCurrentDirectory: () => process.cwd(),
            getCompilationSettings: () => program.getCompilerOptions(),
            getDefaultLibFileName: options => ts.getDefaultLibFilePath(options),
            fileExists: fileName => fileName === targetFileName,
            readFile: fileName => fileName === targetFileName ? source : "",
            readDirectory: ts.sys.readDirectory,
            directoryExists: ts.sys.directoryExists,
            getDirectories: ts.sys.getDirectories,
        };

        const languageService = ts.createLanguageService(servicesHost, ts.createDocumentRegistry());
        const textChanges: ts.TextChange[] = languageService.getFormattingEditsForDocument(targetFileName, {
            convertTabsToSpaces: true,
            insertSpaceAfterCommaDelimiter: true,
            insertSpaceAfterKeywordsInControlFlowStatements: true,
            insertSpaceBeforeAndAfterBinaryOperators: true,
            newLineCharacter: "\n",
            indentStyle: ts.IndentStyle.Smart,
            indentSize: 4,
            tabSize: 4,
        });
        textChanges.sort((a, b) => b.span.start - a.span.start);

        let finalText = source;
        for (const textChange of textChanges) {
            const { span } = textChange;
            finalText = finalText.slice(0, span.start) + textChange.newText
                + finalText.slice(span.start + span.length);
        }

        finalText = finalText.replace(/\/\/ */g, '');

        fs.writeSync(fileHandle, finalText);
        fs.writeSync(fileHandle, '\n');

        fs.closeSync(fileHandle);
    }

    function scanSourceFile(program: ts.Program, sourceFile: ts.SourceFile) {
        sourceFile.statements.forEach(stmt => {
            if (ts.isClassDeclaration(stmt)) {
                const isActive = ts.getJSDocTags(stmt).find(t => t.tagName.text === jsDocMarker);
                if (isActive) {
                    generateClass(program, stmt);
                }
            }
        });
    }

    return function emit(program: ts.Program, _diagnostics: ts.Diagnostic[]) {
        program.getRootFileNames().forEach(file => {
            scanSourceFile(program, program.getSourceFile(file)!);
        });
    }
}